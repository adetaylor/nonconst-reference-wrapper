use autogenerated::{take_const_reference, take_nonconst_reference};
use reference_wrapper::NonConstRef;
use unique_ptr::UniquePtr;

mod autogenerated;
mod reference_wrapper;
mod unique_ptr;

fn main() {
    let mut outer = autogenerated::Outer {
        t: autogenerated::Inner(42),
    };
    // In reality, such NonConstRefs will always be created from pointers
    // passed from C++ so no &mut exists even momentarily
    let mut reference_to_outer = NonConstRef::new(&mut outer);
    reference_to_outer.outer_const_method();
    reference_to_outer.outer_nonconst_method();
    let inner = reference_to_outer.get_t_const();
    inner.t_const_method();
    let inner = reference_to_outer.get_t_non_const();
    let mut inner2 = reference_to_outer.get_t_non_const();
    inner.t_const_method();
    inner2.t_const_method();
    inner2.t_nonconst_method();
    take_const_reference(&inner2); // minor paper cut
    take_nonconst_reference(inner2.clone()); // minor paper cut
    take_nonconst_reference(inner2);
    // In reality, such NonConstRefs will always be created from pointers
    // passed from C++ so no &mut exists even momentarily
    let mut ptr = UniquePtr(&mut outer);
    ptr.as_mut().unwrap().outer_nonconst_method();
    ptr.as_mut().unwrap().outer_const_method();
    ptr.pin_mut().outer_nonconst_method();
    ptr.pin_mut().outer_const_method();
    let _ref_to_ptr = ptr.pin_mut();
    drop(ptr);
    // Does not compile due to lifetimes.
    //    _ref_to_ptr.outer_nonconst_method();
}
